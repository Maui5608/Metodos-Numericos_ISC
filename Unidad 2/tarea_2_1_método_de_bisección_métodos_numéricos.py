# -*- coding: utf-8 -*-
"""Tarea 2.1_Método de bisección_Métodos numéricos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z1YCex9McWpLAbpSdV6eEB5ahJpwdzHB

**Ejercicio 1**
"""

#   Codigo que implementa el esquema numerico
#   del metodo de biseccion
#
#   David Ezequiel Caballero González


import numpy as np
import matplotlib.pyplot as plt

# Definir la función que va introducirse en
# el esquema del metodo de biseccion
def f(x):
    return x**3-4*x-9

# Algoritmo numerico del
# Método de Bisección
def biseccion(a, b, tol=1e-5, max_iter=100):
    if f(a) * f(b) >= 0:
        print("El método de bisección no es aplicable en el intervalo dado.")
        return None

    iteraciones = []
    errores_absolutos = []
    errores_relativos = []
    errores_cuadraticos = []

    c_old = a  # Para calcular errores

    print("\nIteraciones del Método de Bisección:")
    print("Iter |       a       |       b       |       c       |      f(c)      |     Error     ")
    print("-" * 115)

    for i in range(max_iter):
        c = (a + b) / 2
        iteraciones.append(c)

        error_abs = abs(c - c_old)
        error_rel = abs((c - c_old) / c) if c != 0 else 0
        error_cuad = (c - c_old) ** 2

        errores_absolutos.append(error_abs)
        errores_relativos.append(error_rel)
        errores_cuadraticos.append(error_cuad)

        print(f"{i+1:4d} | {a:.8f} | {b:.8f} | {c:.8f} | {f(c):.8f} | {error_abs:.8e} | {error_rel:.8e} | {error_cuad:.8e}")

        if abs(f(c)) < tol or error_abs < tol:
            break

        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

        c_old = c

    return iteraciones, errores_absolutos, errores_relativos, errores_cuadraticos

# Parámetros iniciales
# se introduce el intervalo [a, b]
#a, b = 2, 3
#a, b = 0, 1.5
a, b = 2, 3
iteraciones, errores_absolutos, errores_relativos, errores_cuadraticos = biseccion(a, b)

# Crear la figura
fig, ax = plt.subplots(2, 2, figsize=(12, 10))

# Gráfica de la función y la convergencia de iteraciones
x = np.linspace(a - 1, b + 1, 400)
y = f(x)

ax[0,0].plot(x, y, label=r'$f(x) = x^{3}-4x-9$', color='b')
ax[0, 0].axhline(0, color='k', linestyle='--', linewidth=1)  # Línea en y=0
ax[0, 0].scatter(iteraciones, [f(c) for c in iteraciones], color='red', label='Iteraciones')
ax[0, 0].set_xlabel('x')
ax[0, 0].set_ylabel('f(x)')
ax[0, 0].set_title("Convergencia del Método de Bisección")
ax[0, 0].legend()
ax[0, 0].grid()

# Gráfica del Error Absoluto
ax[0, 1].plot(range(1, len(errores_absolutos)+1), errores_absolutos, marker='o', linestyle='-', color='r')
ax[0, 1].set_yscale("log")  # Escala logarítmica
ax[0, 1].set_xlabel("Iteración")
ax[0, 1].set_ylabel("Error Absoluto")
ax[0, 1].set_title("Error Absoluto en cada Iteración")
ax[0, 1].grid()

# Gráfica del Error Relativo
ax[1, 0].plot(range(1, len(errores_relativos)+1), errores_relativos, marker='o', linestyle='-', color='g')
ax[1, 0].set_yscale("log")  # Escala logarítmica
ax[1, 0].set_xlabel("Iteración")
ax[1, 0].set_ylabel("Error Relativo")
ax[1, 0].set_title("Error Relativo en cada Iteración")
ax[1, 0].grid()

# Gráfica del Error Cuadrático
ax[1, 1].plot(range(1, len(errores_cuadraticos)+1), errores_cuadraticos, marker='o', linestyle='-', color='m')
ax[1, 1].set_yscale("log")  # Escala logarítmica
ax[1, 1].set_xlabel("Iteración")
ax[1, 1].set_ylabel("Error Cuadrático")
ax[1, 1].set_title("Error Cuadrático en cada Iteración")
ax[1, 1].grid()

# Ajustar espacio entre subgráficos
plt.tight_layout()

# Guardar la figura
plt.savefig("biseccion_errores.png", dpi=300)
plt.show()

"""**Ejercicio 2**"""

#   Codigo que implementa el esquema numerico
#   del metodo de biseccion
#
#   David Ezequiel Caballero González


import numpy as np
import matplotlib.pyplot as plt

# Definir la función que va introducirse en
# el esquema del metodo de biseccion
def f(x):
    return np.exp(-x) - x

# Algoritmo numerico del
# Método de Bisección
def biseccion(a, b, tol=1e-5, max_iter=100):
    if f(a) * f(b) >= 0:
        print("El método de bisección no es aplicable en el intervalo dado.")
        return None

    iteraciones = []
    errores_absolutos = []
    errores_relativos = []
    errores_cuadraticos = []

    c_old = a  # Para calcular errores

    print("\nIteraciones del Método de Bisección:")
    print("Iter |       a       |       b       |       c       |      f(c)      |     Error     ")
    print("-" * 100)

    for i in range(max_iter):
        c = (a + b) / 2
        iteraciones.append(c)

        error_abs = abs(c - c_old)
        error_rel = abs((c - c_old) / c) if c != 0 else 0
        error_cuad = (c - c_old) ** 2

        errores_absolutos.append(error_abs)
        errores_relativos.append(error_rel)
        errores_cuadraticos.append(error_cuad)

        print(f"{i+1:4d} | {a:.8f} | {b:.8f} | {c:.8f} | {f(c):.8f} | {error_abs:.8e}")

        if abs(f(c)) < tol or error_abs < tol:
            break

        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

        c_old = c

    return iteraciones, errores_absolutos, errores_relativos, errores_cuadraticos

# Parámetros iniciales
# se introduce el intervalo [a, b]
#a, b = 2, 3
#a, b = 0, 1.5
a, b = 0, 1
iteraciones, errores_absolutos, errores_relativos, errores_cuadraticos = biseccion(a, b)

# Crear la figura
fig, ax = plt.subplots(2, 2, figsize=(12, 10))

# Gráfica de la función y la convergencia de iteraciones
x = np.linspace(a - 1, b + 1, 400)
y = f(x)

ax[0,0].plot(x, y, label=r'$f(x) = e^{-x} - x$', color='b')
ax[0, 0].axhline(0, color='k', linestyle='--', linewidth=1)  # Línea en y=0
ax[0, 0].scatter(iteraciones, [f(c) for c in iteraciones], color='red', label='Iteraciones')
ax[0, 0].set_xlabel('x')
ax[0, 0].set_ylabel('f(x)')
ax[0, 0].set_title("Convergencia del Método de Bisección")
ax[0, 0].legend()
ax[0, 0].grid()

# Gráfica del Error Absoluto
ax[0, 1].plot(range(1, len(errores_absolutos)+1), errores_absolutos, marker='o', linestyle='-', color='r')
ax[0, 1].set_yscale("log")  # Escala logarítmica
ax[0, 1].set_xlabel("Iteración")
ax[0, 1].set_ylabel("Error Absoluto")
ax[0, 1].set_title("Error Absoluto en cada Iteración")
ax[0, 1].grid()

# Gráfica del Error Relativo
ax[1, 0].plot(range(1, len(errores_relativos)+1), errores_relativos, marker='o', linestyle='-', color='g')
ax[1, 0].set_yscale("log")  # Escala logarítmica
ax[1, 0].set_xlabel("Iteración")
ax[1, 0].set_ylabel("Error Relativo")
ax[1, 0].set_title("Error Relativo en cada Iteración")
ax[1, 0].grid()

# Gráfica del Error Cuadrático
ax[1, 1].plot(range(1, len(errores_cuadraticos)+1), errores_cuadraticos, marker='o', linestyle='-', color='m')
ax[1, 1].set_yscale("log")  # Escala logarítmica
ax[1, 1].set_xlabel("Iteración")
ax[1, 1].set_ylabel("Error Cuadrático")
ax[1, 1].set_title("Error Cuadrático en cada Iteración")
ax[1, 1].grid()

# Ajustar espacio entre subgráficos
plt.tight_layout()

# Guardar la figura
plt.savefig("biseccion_errores.png", dpi=300)
plt.show()

"""**Ejercicio 3**"""

#   Codigo que implementa el esquema numerico
#   del metodo de biseccion
#
#   David Ezequiel Caballero González


import numpy as np
import matplotlib.pyplot as plt

# Definir la función que va introducirse en
# el esquema del metodo de biseccion
def f(x):
    return np.cos(x) - x

# Algoritmo numerico del
# Método de Bisección
def biseccion(a, b, tol=1e-5, max_iter=100):
    if f(a) * f(b) >= 0:
        print("El método de bisección no es aplicable en el intervalo dado.")
        return None

    iteraciones = []
    errores_absolutos = []
    errores_relativos = []
    errores_cuadraticos = []


    c_old = a  # Para calcular errores

    print("\nIteraciones del Método de Bisección:")
    print("Iter |       a       |       b       |       c       |      f(c)      |     Error     ")
    print("-" * 85)

    for i in range(max_iter):
        c = (a + b) / 2
        iteraciones.append(c)

        error_abs = abs(c - c_old)
        error_rel = abs((c - c_old) / c) if c != 0 else 0
        error_cuad = (c - c_old) ** 2

        errores_absolutos.append(error_abs)
        errores_relativos.append(error_rel)
        errores_cuadraticos.append(error_cuad)

        print(f"{i+1:4d} | {a:.8f} | {b:.8f} | {c:.8f} | {f(c):.8f} | {error_abs:.8e}")

        if abs(f(c)) < tol or error_abs < tol:
            break

        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

        c_old = c

    return iteraciones, errores_absolutos, errores_relativos, errores_cuadraticos

# Parámetros iniciales
# se introduce el intervalo [a, b]
#a, b = 2, 3
#a, b = 0, 1.5
a, b = 0, 1
iteraciones, errores_absolutos, errores_relativos, errores_cuadraticos = biseccion(a, b)

# Crear la figura
fig, ax = plt.subplots(2, 2, figsize=(12, 10))

# Gráfica de la función y la convergencia de iteraciones
x = np.linspace(a - 1, b + 1, 400)
y = f(x)

ax[0,0].plot(x, y, label=r'$f(x) = \cos(x) - x$', color='b')
ax[0, 0].axhline(0, color='k', linestyle='--', linewidth=1)  # Línea en y=0
ax[0, 0].scatter(iteraciones, [f(c) for c in iteraciones], color='red', label='Iteraciones')
ax[0, 0].set_xlabel('x')
ax[0, 0].set_ylabel('f(x)')
ax[0, 0].set_title("Convergencia del Método de Bisección")
ax[0, 0].legend()
ax[0, 0].grid()

# Gráfica del Error Absoluto
ax[0, 1].plot(range(1, len(errores_absolutos)+1), errores_absolutos, marker='o', linestyle='-', color='r')
ax[0, 1].set_yscale("log")  # Escala logarítmica
ax[0, 1].set_xlabel("Iteración")
ax[0, 1].set_ylabel("Error Absoluto")
ax[0, 1].set_title("Error Absoluto en cada Iteración")
ax[0, 1].grid()

# Gráfica del Error Relativo
ax[1, 0].plot(range(1, len(errores_relativos)+1), errores_relativos, marker='o', linestyle='-', color='g')
ax[1, 0].set_yscale("log")  # Escala logarítmica
ax[1, 0].set_xlabel("Iteración")
ax[1, 0].set_ylabel("Error Relativo")
ax[1, 0].set_title("Error Relativo en cada Iteración")
ax[1, 0].grid()

# Gráfica del Error Cuadrático
ax[1, 1].plot(range(1, len(errores_cuadraticos)+1), errores_cuadraticos, marker='o', linestyle='-', color='m')
ax[1, 1].set_yscale("log")  # Escala logarítmica
ax[1, 1].set_xlabel("Iteración")
ax[1, 1].set_ylabel("Error Cuadrático")
ax[1, 1].set_title("Error Cuadrático en cada Iteración")
ax[1, 1].grid()

# Ajustar espacio entre subgráficos
plt.tight_layout()

# Guardar la figura
plt.savefig("biseccion_errores_cos.png", dpi=300)
plt.show()